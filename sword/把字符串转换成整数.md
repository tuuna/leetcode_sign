**题目描述**
将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0
输入描述:
输入一个字符串,包括数字字母符号,可以为空
输出描述:
如果是合法的数值表达则返回该数字，否则返回0

**题解**

什么样的数值不合法啊，看到题其实没太多头绪

越界的简单解决方案：让符号位参与运算，并合理利用 INT_MAX/10

众所周知，这道题逻辑并不复杂，只是要判断结果是否出界却有点让人手忙脚乱，这里给出以下两种情景的解决方案（若有发现缺漏之处，望及时指出纠正！）：

能够处理最小负数：-2147483648
判断是否超出最小负数 ~ 最大正数的范围
一、关于最小负数：从true、false到 -1、1
一般而言，我们习惯性地使用 bool 类型来表示数字是否为负数（标志位 isNegtive），并在计算过程中使用正数来表示中间结果，只有在最后一步才根据标志 isNegtive 将结果取负，这样一样，因为最大正数的绝对值小于最小负数绝对值，所以当值为 INT_MIN 时，将导致结果出错

事实上， 只要将正负标志的类型由 bool 类型改成 int 类型，当符号为正时，标志为1，符号为负时，标志为 -1，从而使正负标志位可以参与到运算过程中去，就可以巧妙地解决这一问题，：

原先中间值的计算：value = value * 10 + digit;
此时中间值的计算：value = value * 10 + isNegtive * digit;
如此一来，当数值为负时，中间结果也为负，并执行的是减法操作，就可以取得 -2147483648 的值
而当数值为正时，中间结果为正，执行的是加法操作。

二、关于数值越界：合理利用 INT_MAX/10
数值越界，即大于 2147483647，或小于 -2147483648。通过观察程序结构，我们发现，每次循环时 value 的值都会扩大10倍（乘以10），那么，我们是否就可以利用 INT_MAX/10 的值来提前一步判断是否会越界呢？这里我们以正数的越界为例进行解释：

当 value > INT_MAX/10 时，说明本轮扩大10倍后，value 必将越界（超过 INT_MAX）；
当 value == INT_MAX/10 时，说明扩大10倍后，value 可能越界，也可能不越界，需要利用当前的加数 digit 来进行进一步的判断：当 digit > 7 时（以正数为例），越界；
否则，当 value < INT_MAX/10 时，本轮循环必不越界（扩大10倍后也小于 INT_MAX）；
三、将正数、负数的越界判断合并起来：
为了保证代码简洁高效，这里我们不得不寻求一种方法，使正数、负数的越界判断可以合并起来进行（同样，这里我们也利用了数值化的正负标记位 isNegtive）：
我们设置一个变量 overValue 来表示当前的值和 INT_MAX/10 的差，因为 INT_MAX/10 为正数，所以当当前值为负数时，需要统一转化为正数，故而有：

1
overValue = isNegtive*value - INT_MAX/10;
这样，当 overValue > 0 时，越界，overValue < 0 时，不越界，而当 overValue == 0 时：
正数时（isNegtive == 1），digit > 7 越界，负数时（isNegtive == -1），digit > 8 越界，通过 (isNegtive+1)/2 来将 -1、1转换为0、1，从而使有关 digit 的判断统一转化为：

当 (isNegtive+1)/2 + digit > 8 时，数值越界；
综上，令：
overValue = isNegtive*value - INT_MAX/10
          + (((isNegtive+1)/2 + digit > 8) ? 1:0);
则当 overValue > 0 时，数值将会越界，反之，则不会

然后看了下评论区边界条件主要是数据上下溢出、空字符串、只有正负号、有无正负号、错误标志输出

```
public int StrToInt(String str) {
        if (str == null)
            return 0;
        int result = 0;
        boolean negative = false;//是否负数
        int i = 0, len = str.length();
        /**
         * limit 默认初始化为 负的 最大正整数 ，假如字符串表示的是正数
         * 那么result(在返回之前一直是负数形式)就必须和这个最大正数的负数来比较，
         * 判断是否溢出
         */
        int limit = -Integer.MAX_VALUE;
        int multmin;
        int digit;
 
        if (len > 0) {
            char firstChar = str.charAt(0);//首先看第一位
            if (firstChar < '0') { // Possible leading "+" or "-"
                if (firstChar == '-') {
                    negative = true;
                    limit = Integer.MIN_VALUE;//在负号的情况下，判断溢出的值就变成了 整数的 最小负数了
                } else if (firstChar != '+')//第一位不是数字和-只能是+
                    return 0;
                if (len == 1) // Cannot have lone "+" or "-"
                    return 0;
                i++;
            }
            multmin = limit / 10;
            while (i < len) {
                // Accumulating negatively avoids surprises near MAX_VALUE
                digit = str.charAt(i++)-'0';//char转int
                if (digit < 0 || digit > 9)//0到9以外的数字
                    return 0;
 
                //判断溢出
                if (result < multmin) {
                    return 0;
                }
                result *= 10;
                if (result < limit + digit) {
                    return 0;
                }
                result -= digit;
            }
        } else {
            return 0;
        }
        //如果是正数就返回-result（result一直是负数）
        return negative ? result : -result;
    }
```

