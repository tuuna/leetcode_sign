我们常用的存储引擎就MyISAM和InnoDB。MyISAM存储主要就简单的表级别锁，下面只说InnoDB的各种锁类型。

InnoDB不仅支持行级别的锁，也支持表级别的锁。平常我们会听到各种锁，你是不是不仅迷茫它们怎么用的，还会迷茫它们 各自之间都是什么关系？

什么是乐观锁和悲观锁？
乐观锁和悲观锁是泛指，不是具体的锁。

乐悲锁：也叫乐观并发控制，它总是乐观的认为用户在并发事务处理时不会影响彼此的数据。

 悲锁观锁：悲观锁会悲观的认为每次去拿的数据都会被别人修改。所以每次在拿数据的时候都会上锁，从而屏蔽可能违反数据完整性的操作。间隙锁、临键锁都属于悲观锁。

什是表锁和行锁？
 表锁和行锁也是泛指，不是具体的锁。

表级锁有：意向共享锁、意向排他锁、自增锁等。InnoDB的行锁都是实现在索引上的。

行级锁有：共享锁、排他锁、记录锁

什么是共享锁(S锁)和排他锁(X锁)？
InnoDB引擎实现了标准的行级别锁，分别是共享锁和排他锁。

拿共享锁是为了让当前事务去读一行数据。
拿排他锁是为了让当前事务去修改或删除某一行数据。
一个事务拿到了当前数据行的共享锁，另一个事务也能马上拿到当前数据行的共享锁。

一个事务拿到了当前数据行的排他锁，则另一个事务不能立马拿到当前数据行的排他锁，因为它会被阻塞直到前一个事务释放。

设置共享锁：select * from user where id = 1 LOCK IN SHARE MODE;

设置排他锁：select * from user where id = 1 FOR UPDATE;

InnoDB到底有几种锁？
(1) 共享/排它锁(Shared and Exclusive Locks)

(2) 意向锁(Intention Locks)

(3) 记录锁(Record Locks)

(4) 间隙锁(Gap Locks)

(5) 临键锁(Next-key Locks)

(6) 插入意向锁(Insert Intention Locks)

(7) 自增锁(Auto-inc Locks)

临键锁是记录锁和间隙锁的组合。



> 1 脏读：修改时加排他锁，直到事务提交后才释放，读取时加共享锁，读取完释放事务1读取数据时加上共享锁后（这 样在事务1读取数据的过程中，其他事务就不会修改该数据），不允许任何事物操作该数据，只能读取，之后1如果有更新操作，那么会转换为排他锁，其他事务更 无权参与进来读写，这样就防止了脏读问题。
>
> ​    但是当事务1读取数据过程中，有可能其他事务也读取了该数据，读取完毕后共享锁释放，此时事务1修改数据，修改 完毕提交事务，其他事务再次读取数据时候发现数据不一致，就会出现不可重复读问题，所以这样不能够避免不可重复读问题。
>
>    2 不可重复读：读取数据时加共享锁，写数据时加排他锁，都是事务提交才释放锁。读取时候不允许其他事物修改该数据，不管数据在事务过程中读取多少次，数据都是一致的，避免了不可重复读问题
>    3 幻读问题：采用的是范围锁RangeS RangeS_S模式，锁定检索范围为只读，这样就避免了幻影读问题，在这里有个描述范围锁的文章