## 存储引擎

InnoDB vs MyISAM

1. InnoDB支持行级锁、MyISAM只支持表级锁

   > InnoDB行锁是加在索引上的，如果没有走索引，行锁退化为表所

2. 崩溃后的安全恢复：MyISAM发生崩溃后恢复慢且损坏概率高(why?)，而InnoDB因为支持事务、外键等功能，所以其具有事务、回滚、崩溃修复能力的事务安全型表

3. MyISAM不支持外键、InnoDB支持

4. InnoDB支持MVCC，在应对高并发事务时，MVCC比单纯的加锁更加高效；MVCC只在READ COMMITED 和 REPEATABLE READ两个隔离级别下工作；**各数据库的MVCC实现并不统一**

   > 多版本控制是一种提高并发的技术，在最早的数据库系统，只有读读之间可以并发，而读写、写读、写写都要阻塞。MVCC之后只有写写之间相互阻塞。InnoDB通过undo log实现MVCC，，通过undo log找回数据历史版本来给用户读，也可以在回滚的时候覆盖数据页上的数据(内部会记录一个全局的活跃读写事务数组，判断事务的可见性)，InnoDB通过在数据库每行数据后面添加三个隐藏的字段来实现（6字节的事务ID(最后一次修改的事务ID))、7字节的回滚指针(重建该行记录被更新前内容)、6字节的DB_ROW_ID）。在repeatable read级别下，事务在第一条select 读操作后会创建一个快照(read view)。在read commited级别下,事务在每一条select操作都会创建。

## REDO & UNDO

undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：
**1.redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。**
**2.undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录**

> redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。
>
> 在概念上，innodb通过***force log at commit\***机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。
>
> 为了确保每次日志都能写入到事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。因为MariaDB/MySQL是工作在用户空间的，MariaDB/MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(redo:ib_logfileN文件,undo:share tablespace或.ibd文件)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。

## 索引

主要是**B+树**和**哈希索引**

### 聚簇索引和非聚簇索引

**聚簇索引**

* 如果表设置了主键，则主键就是聚簇索引
* 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引
* 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引

> InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。
>
> 由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。

**非聚簇索引**

> 普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。
>
> InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针

### Innodb中的B+树结构有什么特点

**MyISAM**

B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

**InnoDB**

其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 

### 索引查找过程

如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。

如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：select * from user where age = 30;（先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。即所谓的回表）

为了解决回表，采用覆盖索引(联合索引)。只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。

### 为什么要用B+树

B-树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。
这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数据。
从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。
那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。
另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。

至于MongoDB为什么使用B-树而不是B+树，可以从它的设计角度来考虑，它并不是传统的关系性数据库，而是以Json格式作为存储的nosql，目的就是高性能，高可用，易扩展。首先它摆脱了关系模型，上面所述的优点2需求就没那么强烈了，其次Mysql由于使用B+树，数据都在叶节点上，每次查询都需要访问到叶节点，而MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）。

总体来说，Mysql选用B+树和MongoDB选用B-树还是以自己的需求来选择的。

## 读写过程

https://www.jianshu.com/p/44bc68c4afe5
https://www.cnblogs.com/drizzle-xu/p/9869406.html

### 读过程

读操作的IO流程

1、查看缓存中是否存在id，(MySQL已去掉)

2、如果有则从内存中访问，否则要访问磁盘，

3、并将索引数据存入内存，利用索引来访问数据,

4、对于数据也会检查数据是否存在于内存，

5、如果没有则访问磁盘获取数据，读入内存。

6、返回结果给用户。

### 写过程

1、先写undo log。

2、在内存更新数据，这步操作就在内存中形成了脏页，如果脏页过多，checkpoint机制进行刷新，innodb_max_dirty_pages_pct决定了刷新脏页比例。innodb_io_capacity参数可以动态调整刷新脏页的数量，innodb_lru_scan_depth这个参数决定了刷新每个innodb_buffer_pool的脏页数量。

> mysql脏页：
>  当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页；
>  内存数据写入磁盘后，内存页上的数据和磁盘页上的数据就一致了，我们称这个内存页为干净页。
>
> 刷脏页的时机:
>  (1)redo log写满时，没有看见了，此时需要将checkpoint向前推进，推进的这部分日志对应的脏页刷入到磁盘，此时所有的更新全部阻塞，此时写的性能变为0，必须待刷一部分脏页后才能更新。
>  (2)系统内存不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘。
>  (3)MySQL认为空闲的时间，这种没有性能问题。
>  (4) mysql正常关闭之前，会把所有脏页刷入磁盘，不存在性能问题。

3、记录变更到redo log，prepare这里会写事务id。innodb_flush_log_at_trx_commit决定了事务的刷盘方式。为0时，log buffer将每秒一次地写入log file中，并且log file的flush(刷到磁盘)操作同时进行。该模式下，在事务提交的时候，不会主动触发写入磁盘的操作。为1，每次事务提交时MySQL都会把log buffer的数据写入log file，并且flush(刷到磁盘)中去.为2，每次事务提交时MySQL都会把log buffer的数据写入log file.但是flush(刷到磁盘)操作并不会同时进行。该模式下，MySQL会每秒执行一次 flush(刷到磁盘)操作。

4、写入binlog这里会写入一个事务id这里有个sync_binlog参数决定多个事务进行一次性提交。

5、redo log第二阶段，这里会进行判断前2步是否成功，成功则默认commit，否则rollback。刷入磁盘操作。这里是先从脏页数据刷入到内存2M大小的doublewrite buffer，然后是一次性从内存的doublewrite buffer刷新到共享表空间的doublewrite buffer，这里产生了一次IO。然后从内存的内存的doublewrite buffer刷新2m数据到磁盘的ibd文件中，这里需要发生128次io。然后校验，如果不一致，就由共享表空间的副本进行修复。这里有个参数innodb_flush_method决定了数据刷新直接刷新到磁盘，绕过os cache。

6、返回给client。

如果有slave，第4步之后经过slave服务线程io_thread写到从库的relay log ，再由sql thread应用relay log到从库中。

## 主从复制

**主从复制原理，简言之，就三步曲，如下：**

- 主数据库有个bin-log二进制文件，纪录了所有增删改Sql语句。（binlog线程）
- 从数据库把主数据库的bin-log文件的sql语句复制过来。（io线程）
- 从数据库的relay-log重做日志文件中再执行一次这些sql语句。（Sql执行线程）

## 事务

默认RR

## 事务更新过程

当事务A更改该行的值，会进行如下操作：

1. 用排他锁锁定该行
2. 记录redo log
3. 把该行修改前的值Copy到undo log
4. 修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行

> 下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。
>
> - SELECT
>
>   InnoDB会根据以下两个条件检查每行记录：
>
>   1. InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
>   2. 行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
>
>   只有符合上述两个条件的记录，才能返回作为查询结果
>
> - INSERT
>
>   InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
>
> - DELETE
>
>   InnoDB为删除的每一行保存当前系统版本号作为行删除标识。
>
> - UPDATE
>
>   InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。
>    保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

## SQL语句执行过程



## SQL语句执行很慢的原因



