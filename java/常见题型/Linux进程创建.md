# inux进程的创建与撤销

Linux进程的创建有三个函数。fork,vfork和clone。不要把exec系列的函数和这三个函数混为一谈，exec系列函数常用于三者之后，用于创建一个新的程序运行环境。

## clone(), fork(), vfork()

Linux既然有各种各样的机制，那么复制也有着多种手法。这也就对应了这三种创建进程的系统调用。

这三个函数实际上都是C库的封装，内部分别调用了sys_clone, sys_fork, sys_vfork三个系统调用。这三个系统调用又统一调用了do_fork函数，只是携带的参数和标志不同，从而在do_fork中有选择的完成某些任务。

便于理解，先大体来谈谈三者的区别：

- fork
  - 子进程复制父进程的所有资源
- clone
  - 轻量级进程使用clone
- vfork
  - 子进程和父进程共享数据段，子进程每次都优先于父进程执行(这很有意义，后面你会看到)

### fork()

既然Linux的进程是复制的，那么大多数人的第一想法一定是子进程复制整个父进程的资源。诸如最简单的fork，是否只要在调用时完全的深度拷贝即可？实际上深度拷贝所有的资源是没有必要的，Linux指定了3个机制，用于提升性能：

- COW，即写时复制。这一技术的引用就使得父子进程可以在一开始的时候共享物理页（一开始是相同的），当二者其一想要写该物理页时，再真正的copy出页的内容到新分配的物理页，然后进行修改。
- 轻量级进程允许父子进程共享内核的大部分数据结构（页表（用户态地址空间）、打开文件表和信号处理），所以如同在《Linux进程概述》中所说，它更像一个线程。
- vfork()系统调用创建的进程能共享父进程的内存地址空间。为了防止父进程重写子进程所需要的数据，阻塞父进程的执行，直到子进程推出或执行一个新的程序为止。

无论是哪一种机制，其根本的思想是一致的：能省则省，延迟拷贝。

对于fork来说，进程A调用fork创建一个子进程B时，B和A拥有相同的物理页面，为了节约内存和提速，fork()会把A和B的物理页面设置成只读。此后，A或B想要执行写操作时，都会产生页面出错异常(page_fault int14)中断，此时CPU执行异常处理函数do_wp_page()解决该异常。do_wp_page()实际上非常简单，无非就是取消共享，为写进程复制一个新的物理页面（此时才真正进行了开辟和复制），设置权限。异常返回后，继续执行写操作。

### vfork()

比起fork()的延迟懒惰处理，vfork()更加粗暴。内核在复制子进程时，连子进程自身的虚拟地址空间都不创建了，干脆使用了父进程的虚拟空间。既然虚拟空间都霸占了，物理页面也当然共享了（这意味着修改子进程的变量值也会影响父进程）。
于是，vfork为了防止父进程overwrite，设计上会把父进程先挂起，子进程exit或execve时父进程才会被唤起。vfork创建的子进程不应该用return或exit()，但可以用_exit()退出（参考man vfork，exit是_exit()或_exitgroup()的封装，结束子进程，他不会修改函数栈，所以我在测试中exit()没有出错，这应该是一种严格的说法，当然vfork不接exec，要么脑子有坑，要么想干坏事。至于exit()封装的额外操作还有待研究）。

> vfork的子进程如果return就意味着父进程return（共享内存、栈），这看起来没问题，但是接下来父进程再次return就崩了，系统表示很困惑。（return后会自动接exit()，而此时栈已经被破坏了，有些系统会无限循环，再次调用main()，有些直接就segmentation fault）。

那么问题来了，我要这vfork有何用？实际上，vfork只是一个中间步骤，vfork的存在是为了exec的调用。exec是重新开辟空间，那么如果没有vfork，就只得用笨重的fork，而因为下一步想要exec，所以fork的复制过程就毫无意义。

### clone()

clone是给轻量级进程的，但clone本身的设计很强大，他可以有选择性的让子进程继承资源。

clone结构：`int clone(int (fn)(void ), void *child_stack, int flags, void *arg, ...);`

fn是函数指针，指向程序的指针，函数返回时子进程终止并返回一个退出码；child_stack是子进程堆栈；flags表示从父进程继承哪些资源；arg为传递给子进程的参数。

flags取值是一组宏，几个常见的标志：

- CLONE_VM
  - 共享内存描述符和所有的页表
- CLONE_FS
  - 共享根目录和当前工作目录所在的表，以及用于屏蔽新文件初始许可权的位掩码值
- CLONE_FILES
  - 共享打开文件表
- CLONE_SIGHAND
  - 共享信号处理程序的表、阻塞信号表和挂起信号表。如果标记为true，必须设置CLONE_VM
- CLONE_PTRACE
  - 如果父进程被跟踪，那么子进程也被跟踪。
- CLONE_VFORK
  - vfork()系统调用时设置
- CLONE_PARENT
  - 设置子进程的父进程为调用进程的父进程
- CLONE_THREAD
  - 把子进程插入到父进程的同一线程组中，使子进程共享父进程信号描述符。因此子进程的tgid和group_leader字段也被设置。如果该标记为true，必须设置CLONE_SIGHAND
- CLONE_NEWNS
  - 当clone需要自己的命名空间时设置这个标志。CLONE_NEWNS和CLONE_FS互斥。
- CLONE_PID
  - 子进程创建时PID和父进程一致

clone()是libc定义的封装函数，clone()系统调用的服务例程是sys_clone()，它没有fn和arg参数（clone()把fn指针放在了子进程堆栈的某个位置，arg在fn下面），clone()返回后，取出的地址就是fn，参数就是arg，顺理成章执行fn(arg)。

### 系统调用服务例程

实际上我在看glibc 2.19时发现整个流程非常的复杂，有兴趣的可以自己跟一下。但无论如何，我只需要知道，最终的系统调用对应的服务例程是sys_fork等函数就够了。