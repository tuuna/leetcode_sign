abstract class和interface在Java语言中都是用来进行抽象类（本文中的抽象类并非从abstract class翻译而来，它表示的是一个抽象体，而abstract class为Java语言中用于定义抽象类的一种方法）定义的，那么什么是抽象类，使用抽象类能为我们带来什么好处呢？

声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。

接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现 这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。 然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到 接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。

接口可以继承接口。抽象类可以实现(implements)接口，抽象类是可以继承实体类，但前提是实体类必须有明确的构造函数。接口更关注“能实现什么功能”，而不管“怎么实现的”。

**1.相同点**
 A. 两者都是抽象类，都不能实例化。
 B. interface实现类及abstrct class的子类都必须要实现已经声明的抽象方法。

**2. 不同点**
 A. interface需要实现，要用implements，而abstract class需要继承，要用extends。
 B. 一个类可以实现多个interface，但一个类只能继承一个abstract class。
 C. interface强调特定功能的实现，而abstract class强调所属关系。
 D. 尽管interface实现类及abstrct class的子类都必须要实现相应的抽象方法，但实现的形式不同。interface中的每一个方法都是抽象方法，都只是声明的 (declaration, 没有方法体)，实现类必须要实现。而abstract class的子类可以有选择地实现。
 这个选择有两点含义：
  一是Abastract class中并非所有的方法都是抽象的，只有那些冠有abstract的方法才是抽象的，子类必须实现。那些没有abstract的方法，在Abstrct class中必须定义方法体。
  二是abstract class的子类在继承它时，对非抽象方法既可以直接继承，也可以覆盖；而对抽象方法，可以选择实现，也可以通过再次声明其方法为抽象的方式，无需实现，留给其子类来实现，但此类必须也声明为抽象类。既是抽象类，当然也不能实例化。
 E. abstract class是interface与Class的中介。
 interface是完全抽象的，只能声明方法，而且只能声明pulic的方法，不能声明private及protected的方法，不能定义方法体，也 不能声明实例变量。然而，interface却可以声明常量变量，并且在JDK中不难找出这种例子。但将常量变量放在interface中违背了其作为接 口的作用而存在的宗旨，也混淆了interface与类的不同价值。如果的确需要，可以将其放在相应的abstract class或Class中。
 abstract class在interface及Class中起到了承上启下的作用。一方面，abstract class是抽象的，可以声明抽象方法，以规范子类必须实现的功能；另一方面，它又可以定义缺省的方法体，供子类直接使用或覆盖。另外，它还可以定义自己 的实例变量，以供子类通过继承来使用。

**3. interface的应用场合**
 A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
 B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
 C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
 D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

**4. abstract class的应用场合**
 一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：
 A. 定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
 B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
 C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。



一、抽象类： 
在面向对象领域，抽象类主要用来进行类型隐藏。那什么是类型隐藏呢？我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。这个抽象描述就是抽象类，而这一组任意个可能的具体实现则表现为所有可能的派生类。好比，动物是一个抽象类，人、猴子、老虎就是具体实现的派生类，我们就可以用动物类型来隐藏人、猴子和老虎的类型。( 参考doSome方法)
         二、接口： 
接口是什么呢？Java中的接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。接口是一种特殊形式的抽象类。
          三、抽象类和接口的区别： 
首先，抽象类在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个接口。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。 其次，在抽象类的定义中，我们可以赋予方法的默认行为。但是在接口的定义中，方法却不能拥有默认行为，为了绕过这个限制，必须使用委托，但是这会 增加一些复杂性，有时会造成很大的麻烦。 抽象类在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is a”关系，即父类和派生类在概念本质上应该是相同的。对于接口来说则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已。接口表示的是”like a”关系。 使用抽象类来定义允许多个实现的类型，比使用接口有一个明显的优势：抽象类的演化比接口的演化要容易的多。在后续的发行版中，如果希望在抽象类中增加一个方法，只增加一个默认的合理的实现即可，抽象类的所有实现都自动提供了这个新的方法。对于接口，这是行不通的。虽然可以在骨架实现类中增加一方法的实现来解决部分问题，但这不能解决不从骨架实现类继承的接口实现的问题。由此，设计公有的接口要非常谨慎，一旦一个接口被公开且被广泛实现，对它进行修改将是不可能的。 所以，使用接口还是抽象类，取决于我们对问题的概念的本质理解和设计的意图。 
    Java接口与抽象类的相同点： 
       1. 都不能被实例化。 
       2. 都能包含抽象方法。 
抽象类与接口紧密相关。然接口又比抽象类更抽象，这主要体现在它们的差别上：1）类可以实现无限个接口，但仅能从一个抽象（或任何其他类型）类继承，从抽象类派生的类仍可实现接口，从而得出接口是用来解决多重继承问题的。2）抽象类当中可以存在非抽象的方法，可接口不能且它里面的方法只是一个声名必须用public来修饰没有具体实现的方法。3）抽象类中的成员变量可以被不同的修饰符来修饰，可接口中的成员变量默认的都是静态常量（static fainl）。4）这一点也是最重要的一点本质的一点"抽象类是对象的抽象，然接口是一种行为规范"。 
例如每个接口可以代表一种最顶层的抽象，可以理解为代表一类东西，如果一个类实现了多个接口，那这个类就有了多种类型，即接口是定义混合类型的理想工具最后：有一种设计模式，就是，默认适配模式，意思就是说，首先定义一个接口，通过抽象类实现这个接口，并实现一些子类不需要一定实现的方法，然后，子类就可以选择是继承接口，实现所有方法，还是直接继承这个抽象类实现具体需要的方法， 

四、为什么用抽象类


定义成抽象类是为了以后要其子类来继承的，因为父类里有很多方法是无法定义具体的实现的，只能定义一个原型，让子类来分别实现！所以要定义成抽象的！
简单来说就是
抽象类是在接口和实体类之间的一个桥梁 
例如 
做一个接口叫做飞行FlyAnimalAction，里面定义一个方法叫做flying，再定义一个方法叫做eat 
做一个类叫做蚊子实现接口，蚊子要实现flying方法，实现自己的eat方法 
做一个类叫做苍蝇实现接口，苍蝇也要实现flying方法，实现自己的eat方法 
你发现所有会飞的动物都要实现这个接口，很麻烦，不如 
做一个抽象类FlyAnimal,然后实现上面的接口 
在里面实现flying这个方法，因为大部分的飞行动作是一样的，而eat方法则继续写成抽象方法，因为大部分的动物吃东西是不一样的 
下面你再写蚊子类就简单了，可以直接继承这个抽象类，然后实现自己的吃方法就行了 
而且苍蝇类的制作也是一样，这个时候抽象类的功能就显示出来了，当然抽象类的功能远远不是这些，只是初期理解到这里就够了。
