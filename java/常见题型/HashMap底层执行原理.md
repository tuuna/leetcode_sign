# HashMap

## HashMap存储结构

数组、链表、红黑树(jdk1.8)

HashMap不扩容默认是16长度的数组

如果有hash冲突的话，会使用单向链表解决冲突

## HashMap特点

1. 快速存储
2. 快速查找(O(1))
3. 可伸缩

## Hash算法

- hash算法
所有的对象都有hashCode(使用key的)
hash值的计算：`(hashCode) ^ (hashCode >>> 16)`

- 数组下标计算
数组默认大小：16
数组下标：hash&(16-1) = hash%16(用与运算效率高)

10 11 12 13 14 15
=  =  =  =  =  = 
         || next
         \/
         key1
         || next
         \/
         key2

比如13号位冲突了，那么就加入一个next记录下一个节点

但是链表过长，效率很低(如果桶下面有一条长链表，这时候hashMap相当于一个单链表，时间复杂度为O(n)，失去了hashmap的优势)于是引入红黑树(在链表长度大于8的时候，将后面的数据存在红黑树中，小于6则变回链表,这里是因为大小为3或4的桶维护树代价将是非常昂贵的，主要是内存占用与查找时间复杂度的权衡)

为什么不引入二叉查找树呢？
因为二叉查找树的一般操作的执行时间为O(lgn)，但是二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。与单链表一样。

hashMap的扩容机制？为什么是2倍扩容？
https://www.iteye.com/blog/annegu-539465
0、75时进行扩容(基于时间和空间的考虑),2倍扩容是因为二进制





