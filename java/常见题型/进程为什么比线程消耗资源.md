## 线程调度为什么比进程调度更少开销？

在对比进程调度与线程调度的开销前，我们需要明白两点：

- 进程与线程的差异
- 任务调度的开销

### 进程与线程的差异

我们首先要明白，线程和进程有什么关系？**从概念上来讲**，线程是进程的一部分，只是任务调度相关的部分，所以我们才说，**“线程是调度的最小单位”**。进程拥有着资源，这些资源不属于某一个特定线程，因为所有线程共享进程拥有的资源，所以我们才说，**“进程是资源分配的最小单位”**。需要特别说明的是，Linux在线程与进程的实现上与概念上有少许差别，这个等下再讨论。

 所以，我们fork一个新的进程时，实际上“伴生”了一个线程，而这个唯一的线程，实际上代表了这个进程参与到任务调度。在执行的过程中，进程通过`pthread_create`创建了更多的线程，例如上图中的线程2，线程n。此时，不管线程1，线程2，还是线程n，他们都代表了进程进行任务调度。

既然我们知道了进程与线程有什么关系，那么实际的linux内核是怎么实现进程与线程的呢？

在linux中，不管进程还是线程，都用`struct task_struct`描述。

```C
struct task_struct {
	...
	struct mm_struct *mm; /*内存资源*/
	...
}
12345
```

既然都是用`struct task_struct`描述，那么进程和线程的关系怎么体现？资源指针！例如上面代码块描述的结构成员`struct mm_struct *mm`，这是一个指针，指向实际的内存资源。同一个进程内的所有线程，他们都使用相同的资源，只需要把对应的资源指针指向相同的地址。

Linux内核就好像淡化了“线程”的概念，每一个线程描述都是`struct task_struct`，他们都是一个独立的“进程”，都有着自己的进程号，都参与任务调度，只不过指向相同的进程资源。

### 任务调度的开销

既然我们知道了进程和线程在linux实现上的关系，我们再来分析，为什么说线程调度比进程调度开销更小？

或许你有这样的疑问，既然在linux实现上，线程都是独立的`struct task_struct`，都参与任务调度，那这里说的线程调度和进程调度怎么区分？

我们不妨这样定义：

```
线程调度：使用相同资源的`struct task_struct`之间的调度
进程调度：使用不同资源的`struct task_struct`之间的调度
12
```

基于这样的定义，为了方便分析问题，我们回顾一下任务调度的开销主要有什么？

```
1. CPU执行任务调度的开销，主要是进程上下文切换的开销
2. 任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销
```

对于第1点的开销，不管是*进程调度*还是*线程调度*都是必须的，所以，两者的差异体现在第2点。

再看回我们对“进程调度”和“线程调度”的定义，有没觉得灵光一闪？既然线程调度的`struct task_struct`都使用相同的资源，是不是就意味着，我即使切换到了其他的线程，CPU Cache/TLB命中的概率会高很多？相反，进程调度使用的是不同的资源，每次换了个进程，就意味着原有的Cache就不适用了，没命中，就触发更多的缺页中断，开销自然就更多。

所以，我们明白了，线程调度为什么比进程调度更少开销。