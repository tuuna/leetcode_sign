## Redis高性能的原因

1. 内存中，计算机，内存中数据库存取最快

2. set key value 简单内存，快

3. 单线程(**省去了很多上下文切换线程的时间**,多线程花费资源)

4. 多路复用(O多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。**epoll中的读、写、关闭、连接都转化成了事件**，然后利用epoll的多路复用特性，绝不在io(指的是网络io或磁盘io，全部在内存里处理，速度就是快)上浪费一点时间。)

5. resp协议很简单，解析快

   >为什么 Redis 中要使用 I/O 多路复用这种技术呢？
   >
   >首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 **I/O 多路复用**就是为了解决这个问题而出现的。
   >
   >https://draveness.me/redis-io-multiplexing/
   >
   >IO多路复用
   >
   >多路，就是多个连接/请求。
   >复用，就是前面说的单线程，即只有一个线程处理所有的连接请求/命令。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。
   >
   >一个简单的例子
   >
   >下面举一个例子，模拟一个tcp服务器处理30个客户socket。
   >假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：
   >
   >\1. 第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。
   >这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。
   >\2. 第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。
   >\3. 第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 
   >这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。
   >这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式。
>
   >**Java中的NIO使用epoll**
   
   >https://www.jianshu.com/p/dfd940e7fca2
   >
>1. 单线程模型不能有阻塞，一旦发生任何阻塞（包括计算机计算延迟）都会使得这个模型不如多线程。**另外，单线程模型不能很好的利用多核cpu**。
   >2. 既然不能有阻塞，那我们只有用多线程去做异步io，那马上就会面临回掉地狱。

   

   
   
   

